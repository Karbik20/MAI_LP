#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Сафонникова А.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |



## Введение

Решение логических задач имеет 2 основных подхода: метод порождения и проверок, метод ветвей и границ. Главное их свойство в том, что они перебирают набор решений, и проверяют, удовлетворяет ли этот набор заданным условиям. 

Отличие данных подходов заключается в методе проверки 'принадлежности' заданным условиям. Первый метод состоит из двух частей: части генератора (генерация множества исходных данных) и части проверяющего (проверка пришедшего решения). Во втором методе проверяющий и генератор уже тесно связаны: генерация всех условий происходит не моментально (сразу все), а постепенно (шагами). Значительные части возможных, но неверных решений отсекаются на ранних шагах. Метод ветвей и границ более сложен по сравнению с методом порождения и проверок, но значительно производительней, поэтому он предпочтительней.

## Задание

Вариант №22:


В одной школе уроки по биологии, географии, английскому языку, французскому языку, истории и математике вели три учителя Морозов, Васильев и Токарев. Каждый из них преподавал два предмета. Учитель географии и учитель французского языка соседи по дому. Морозов самый младший из троих. Все трое Токарев, учитель биологии и учитель французского языка ездят из школы вместе. Учитель биологии старше учителя математики. В свободное время, если им удастся найти четвертого партнера, учитель английского языка, учитель математики и Морозов играют в домино. Кто какие предметы преподает?

## Принцип решения

Сначала мы перечисляем, какие учителя у нас есть и какие предметы они ведут. Далее создаём предикат `teacher`, который содержит информацию об учителе и предметах, а так же будет выводится в качестве ответа через предикат `solve` ввиде списка, после начинаем проверку на правильность фактов, которые известны из условия задачи, с помощью предиката `member`.

Пример того, как мы определяем факт:

У нас есть такое предложение: Учитель биологии старше учителя математики.
Из этого мы понимаем, что учитель биологи и учитель математики - это разные люди, а так как наши предметы у учителей не повторяются, то запишем следующим образом:
```prolog
not(member(teacher(_,biology,maths),Solve)),
not(member(teacher(_,maths,biology),Solve)),
```
Т е учитель не может одновременно преподавать математику и биологию. Таким образом мы записываем каждое из условий.

## Решение

```prolog
% проверка на единственность факта
unique([]):-!.
unique([H|T]):-
member(H,T),!,fail;
unique(T).

% перечислим учителей: Морозова, Васильева и Токарева
man(morozov).
man(vasiliev).
man(tokarev).
 
% перечислим предметы, которые они преподают: история, французкий, биология, английский, математика и география
subject(history).
subject(french).
subject(biology).
subject(english).
subject(maths).
subject(geography).
 
% теперь создадим предикат 'учитель' и проверим все известные факты из условия, выведем ответ
teacher(S,L1,L2).
solve(Solve):-
Solve = [teacher(X,XL1,XL2),teacher(Y,YL1,YL2),teacher(Z,ZL1,ZL2)],
man(X), man(Y), man(Z), not(X=Y),not(Y=Z),not(X=Z),
subject(XL1),subject(XL2),
subject(YL1),subject(YL2), 
subject(ZL1),subject(ZL2), 
unique([XL1,XL2,YL1,YL2,ZL1,ZL2]),
not(member(teacher(_,geography,french),Solve)),
not(member(teacher(_,french,geography),Solve)),
not(member(teacher(tokarev,biology,_),Solve)),
not(member(teacher(tokarev,_,biology),Solve)),
not(member(teacher(tokarev,french,_),Solve)),
not(member(teacher(tokarev,_,french),Solve)),
not(member(teacher(_,biology,french),Solve)),
not(member(teacher(_,french,biology),Solve)),
not(member(teacher(morozov,biology,_),Solve)),
not(member(teacher(morozov,_,biology),Solve)),
not(member(teacher(_,biology,maths),Solve)),
not(member(teacher(_,maths,biology),Solve)),
not(member(teacher(_,english,maths),Solve)),
not(member(teacher(_,maths,english),Solve)),
not(member(teacher(morozov,_,english),Solve)),
not(member(teacher(morozov,english,_),Solve)),
not(member(teacher(morozov,_,maths),Solve)),
not(member(teacher(morozov,maths,_),Solve)),
!.
   
```
Ответ, который выводит программа:
```
?- solve(X).
X = [teacher(vasiliev, biology, english), teacher(morozov, french, history), teacher(tokarev, maths, geography)].
```

## Выводы

Сложность алгоритма составляет O(n^n), так как используются несколько вложенных предикатов `member`, но так как стоит отсечение, зацикливания не происходит, программа работает быстрее.

Данная лабораторная работа показала мне, что можно решать логические задачки не только с помощью ручки и бумаги. Такой язык, как Prolog, оказался удобным для решения подобных задач, тем более, когда они могут быть сложны для быстрого понимания челоческим мозгом или не по силу в целом. 

Данная задача была довольно простая для решения на листочке через математику, но если брать более сложные логические задачи, где надо рассмотреть большое количество возможных вариантов, то с этим нам и может помочь программа на прологе, которая сама переберёт эти случаи и просто выдаст ответ, при этом потратив намного меньше времени, чем если бы мы решали через математику какими-либо общепринятыми методами, ведь не зря в методичке Зайцева писалось, что математика делает то, что можно, как нужно, а информатика то, что нужно, как можно, а решение 'как можно' окажется намного проще, ведь оно решено без лишних усложнений и ухода куда-то в дебри.





